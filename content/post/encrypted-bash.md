+++
categories = [ "Операционные системы", "Разработка" ]
date = "2017-05-05T16:45:01+03:00"
draft = false
tags = [ "unix", "linux", "разработка", "shell", "безопасность" ]
title = "Варианты обфускации bash-скриптов"
toc = true
+++

У одного моего друга есть необходимость защитить шелл скрипты, в которых могут фигурировать или имена серверов, или пароли от нежелательного копания и ничайного запуска. Он задал мне вопрос - как же это можно реализовать - я задумался и нашел несколько вариантов.

<!--more-->

# Вариант первый - самый плохой и ненадежный, но самый очевидный(Base64)

Часть скрипта, которую мы хотим зашифровать выносим в отдельный файл(просто вырезая), прогоняем через base64 - делается это очень просто одноименной командой, вставляем результат в переменную, из которой обратно дешифруем с помощью base64 и исполняем.

Т.е. получаем примерно следующее:

```
#!/usr/bin/env bash
ENC_VAR="ZWNobyAiaGVsbG8gd29ybGQhIgo="                                      
echo $ENC_VAR | base64 -d | source /dev/stdin  
```

Плюсы:
 
 - Легко реализовать
 - Легкая защита от дурака
 - base64 есть почти на любой unix-системе

Минусы:

 - Легко расшифровать
 - Нет парольной защиты
 - Base64 видно невооруженным глазом -- сразу будет понятно, как расшифровать

# Вариант второй - трансляция shell-скриптов в Си

Еще один способ непарольной защиты скриптов от изучения - использование bash-to-c транслятора [shc](http://freecode.com/projects/shc).

Он позволяет получить либо практически не читаемый Си-файл, либо сразу исполняемый двоичный файл. 

Плюсы:
 
 - Легко использовать
 - Защита от прочтения файла
 - Полученный файл не имеет зависимостей от внешних библиотек

Минусы:

 - Файл все еще доступен каждому 
 - Необходимо внешнее приложение

# Вариант третий - шифрование

С вытесняющей вероятностью на машине, где будут храниться и исполняться эти скрипты есть openssl. 

А его можно использовать как раз для шифрования. 

Для того, чтобы зашифровать наш скрипт выполним команду:

```
$ openssl bf < our_script.sh > our_script.sh.enc
```

По выполнению которой будет запрошен пароль и на выходе мы получим зашифрованный файл(оригинальный ес-но останется, что с ним делать - это уже нам решать).

Выполнить же зашифрованный скрипт можно будет командой:
```
$ openssl bf -d < our_script.sh.enc | bash 
```

Плюсы:

 - Парольная защита
 - Шифрование
 - Не возможно декодировать без знания пароля
 - OpenSSL есть почти везде

Минусы:
 
 - OpenSSL все же нужен
 - Требуется ввод пароля
 - Сложнее(но все же можно) сделать шифрование только части файла, не разнося на разные куски


